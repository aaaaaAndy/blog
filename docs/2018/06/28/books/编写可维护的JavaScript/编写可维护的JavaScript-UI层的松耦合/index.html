<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta name="keywords" content="hexo, andy" />
    <title>
        aaaaaAndy
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="img/favicon.ico" />
     
<link rel="stylesheet" href="/blog/css/style.css">


    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" />
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
<!--    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>-->

    <script>
        // infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/blog/" class="logo">
                aaaaaAndy
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/blog/" class="logo">
            aaaaaAndy
        </a>
    </h1>
    <h2 class="desc">
        
    </h2>

    <div class="links">
        <ul id="menu-inner" class="menu-inner">
            
            <li class="menu-inner-item">
                <a href="/blog/">
                    Home
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/category">
                    Category
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/tag">
                    Tag
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/about">
                    About
                </a>
            </li>
            
        </ul>
    </div>
</header>

        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/blog/categories/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84JavaScript/">
            编写可维护的JavaScript
        </a>
    </h4>
    
    
    <h2 class="post-title">
        编写可维护的JavaScript-UI层的松耦合
    </h2>
    <ul class="post-date">
        <li>
            2018-06-28
        </li>
        <li>
            aaaaaAndy
        </li>
    </ul>
    <div class="post-content">
        <html><head></head><body><p>在web开发中，用户界面中是由三个彼此隔离又相互作用的层定义的：</p>
<ul>
<li>HTML用来定义页面的数据和语义。</li>
<li>CSS用来给页面添加样式，创建视觉特征。</li>
<li>JavaScript用来给页面添加行为，使其更具交互性。</li>
</ul>
<p>很多设计模式就是为了解决紧耦合的问题。如果两个组件耦合太紧，则说明一个组件和另一个组件直接相关，这样的话，如果修改一个组件的逻辑，那么另外一个组件的逻辑也要修改，这是很致命的。</p>
<p>当你做到修改一个组件而不需要更改其他的组件时，就做到了松耦合。对于多人大型系统来说，有很多人参与维护代码，松耦合对于代码可维护性来说至关重要。</p>
<p>需要注意的是：在一起工作的额组件无法达到“无耦合”。在所有系统中，组件之间总要共享一些信息来完成各自的工作。这很好理解，我们的目标是确保对一个组件的修改不会经常性地影响其他部分。</p>
<h1 id="1-将CSS从JavaScript中抽离出来"><a href="#1-将CSS从JavaScript中抽离出来" class="headerlink" title="1. 将CSS从JavaScript中抽离出来"></a>1. 将CSS从JavaScript中抽离出来</h1><p>有时候，保持CSS和JavaScript之间清晰的分离是很有挑战的。这两门语言相互协作得很不错，所以我们经常讲CSS和JavaScript混在一起写。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line">element.style.color = <span class="string">"red"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>如上，这种方法是有问题的，因为样式信息是通过JavaScript而非CSS来承载的。当出现了样式问题，你通常首先会去查找CSS，知道你精疲力竭得排除了所有可能性，才会去JavaScript中查找样式信息。</p>
<p>讲CSS从JavaScript中抽离出来意味着所有的样式信息都应当保持在CSS中。当需要哦通过JavaScript来修改元素样式的时候，最佳的方法是操作CSS的className，比如，我想再页面中显示一个对话框，在CSS中的样式定义是像下面这样的。</p>
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.reveal</span> {</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: visible;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后在JavaScript中像这样将样式添加至元素。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法 — jQuery</span></span><br><span class="line">$(element).addClass(<span class="string">"reveal"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>有一种使用style属性的情形是可以接受的：当你需要给页面中的元素作定位，使其相对于另一个元素或整个页面重新定位。这种计算是无法再CSS 中完成的，因此这时是可以使用style.top、style.left等来对元素进行定位的，在CSS中定义这个元素的默认属性，而在JavaScript中修改这些默认值。</p>
<h1 id="2-将JavaScript从HTML中抽离"><a href="#2-将JavaScript从HTML中抽离" class="headerlink" title="2. 将JavaScript从HTML中抽离"></a>2. 将JavaScript从HTML中抽离</h1><p> 很多人学习JavaScript之初都是将脚本嵌入到HTML中来运行，这种写法在2000年的时候非常流行。HTML代码中放满了onclick和其他时间处理程序，很多元素都包含这样的属性。尽管这种代码在多数场景下是正常工作的，但却是两个UI层的深耦合，因此这种写法是有一些问题的。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'action-btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, doSomething, <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>这种方法的优势在于，函数doSomething()的定义和事件处理程序的绑定都是在一个文件中完成的，如果函数名称需要修改，则只需要修改一个文件；如果发生点击时想额外做一些动作，也只需要一处做修改。</p>
<h1 id="3-将HTML从JavaScript中抽离"><a href="#3-将HTML从JavaScript中抽离" class="headerlink" title="3. 将HTML从JavaScript中抽离"></a>3. 将HTML从JavaScript中抽离</h1><p>正如我们需要将JavaScript从HTML中抽离一样，最好也将 HTML从JavaScript中抽离。就像上文提到的，当需要调试一个文本或结构性的问题时，更希望从HTML开始调试，而不是忙活了半天，发现出问题的部分在JavaScript中的HTML语句中。</p>
<h3 id="方法1：从服务器加载"><a href="#方法1：从服务器加载" class="headerlink" title="方法1：从服务器加载"></a>方法1：从服务器加载</h3><p>第一种方法是将模板放置于远程服务器，使用XMLHttpRequest对象来获取外部标签。相比于多页应用，这种方法对单页应用带来更多的便捷。例如，点击一个链接，希望弹出一个新的对话框，代码可能如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadDialog</span> (<span class="params">name, oncomplete</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"get"</span>, <span class="string">"js/dialog"</span> + name, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> && xhr.status == <span class="number">200</span>) {</span><br><span class="line">            <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"dlg-holder"</span>);</span><br><span class="line">            div.innerHTML = xhr.responseText;</span><br><span class="line">            oncomplete();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里没有将HTML字符串嵌入在JavaScript里，而是向服务器发起请求获得字符串，这样可以让HTML代码以最合适的方式注入到页面中。当你需要注入大段HTML标签到页面中时，使用远程调用的方式来加载标签是非常有帮助的。出于性能的原因，将 大量没有用的标签存放于内存或DOM中是很糟糕的做法。</p>
<h3 id="方法2：简单客户端模板"><a href="#方法2：简单客户端模板" class="headerlink" title="方法2：简单客户端模板"></a>方法2：简单客户端模板</h3><p>客户端模板是一些带插槽的标签片段，这些插槽会被JavaScript程序替换为数据以保证模板的完整可用。比如，一段用来添加数据项的模板看起来就像下面这样：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">li</span>></span><span class="tag"><<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%s"</span>></span>%s<span class="tag"></<span class="name">a</span>></span><span class="tag"></<span class="name">li</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>这段模板中包含%s这个占位符，这个位置的文本会被替换掉，JavaScript程序会将这些占位符替换为真实数据，然后将结果注入DOM。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sprintf</span> (<span class="params">text</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/%s/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        <span class="keyword">return</span> (i < args.length) ? args[i++] :  <span class="string">""</span>;</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将模板文件传入JavaScript是这个过程的重要一环。本质上讲，你一点也不希望JavaScript中嵌入模板文本，而是将模板放置于他处。通常我们将模板定义在其他标签之间，直接存放于HTML页面里，这样可以被JavaScript读取，用两种方法即可做到：一种是在HTML注释中包含模板文本。注释是和元素及文本一样的DOM节点，因此可以通过JavaScript将其提取出来。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>></span></span><br><span class="line">    <span class="comment"><!--<li id="item%s"><a href="%s">%s</a></li>--></span></span><br><span class="line">    <span class="tag"><<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item1"</span>></span><span class="tag"><<span class="name">a</span> <span class="attr">href</span>=<span class="string">"item1"</span>></span>First Item<span class="tag"></<span class="name">a</span>></span><span class="tag"></<span class="name">li</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item2"</span>></span><span class="tag"><<span class="name">a</span> <span class="attr">href</span>=<span class="string">"item2"</span>></span>Second item<span class="tag"></<span class="name">a</span>></span><span class="tag"></<span class="name">li</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ul</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>提取步骤如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">'myList'</span>);</span><br><span class="line"><span class="keyword">var</span> templateText = Obj.firstChild.nodeValue;</span><br></pre></td></tr></tbody></table></figure>

<p>另一种方法是使用一个带有自定义type属性的<script>元素，浏览器会默认将<script>元素中的内容识别为JavaScript代码，但你可以通过给type赋值为浏览器不识别的类型，来告诉浏览器这不是一段JavaScript脚本，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"test/x-my-template"</span> <span class="attr">id</span>=<span class="string">"list-item"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item%s"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"%s"</span>&gt;</span>%s<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你可以通过<script>标签的text属性来提取文本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">'list-item'</span>);</span><br><span class="line"><span class="keyword">var</span> templateText = Obj.text</span><br></pre></td></tr></table></figure>

<p>最后在将所提取出来的模板文本通过innerHtml方法注入到HTML文件中。</p>
<h3 id="方法3-复杂客户端模板"><a href="#方法3-复杂客户端模板" class="headerlink" title="方法3. 复杂客户端模板"></a>方法3. 复杂客户端模板</h3><p>可以考虑使用健壮的模板类库，Handlebars是专为浏览器JavaScript设计的完整的客户端模板系统，有技术文档可查阅，此处不再赘述！</p>
<p>handlebars.js :   <a href="http://handlebarsjs.com/expressions.html" target="_blank" rel="noopener">http://handlebarsjs.com/expressions.html</a></p>
<a id="more"></a>
</script></p></body></html>
    </div>
</article>
        </main>
    </div>
</body>

</html>
