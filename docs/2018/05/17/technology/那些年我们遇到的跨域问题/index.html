<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta name="keywords" content="hexo, andy" />
    <title>
        aaaaaAndy
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="img/favicon.ico" />
     
<link rel="stylesheet" href="/blog/css/style.css">


    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" />
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
<!--    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>-->

    <script>
        // infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/blog/" class="logo">
                aaaaaAndy
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/blog/" class="logo">
            aaaaaAndy
        </a>
    </h1>
    <h2 class="desc">
        
    </h2>

    <div class="links">
        <ul id="menu-inner" class="menu-inner">
            
            <li class="menu-inner-item">
                <a href="/blog/">
                    Home
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/category">
                    Category
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/tag">
                    Tag
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/about">
                    About
                </a>
            </li>
            
        </ul>
    </div>
</header>

        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/blog/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">
            浏览器
        </a>
    </h4>
    
    
    <h2 class="post-title">
        那些年我们遇到的跨域问题
    </h2>
    <ul class="post-date">
        <li>
            2018-05-17
        </li>
        <li>
            aaaaaAndy
        </li>
    </ul>
    <div class="post-content">
        <html><head></head><body><p>关于跨域问题的三三两两。</p>
<h1 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1. 同源策略"></a>1. 同源策略</h1><p>跨域的根本原因是浏览器的<strong><em>同源策略</em></strong>，那么什么是同源策略呢？</p>
<p>同源策略，它是由Netscape提出的一个著名的安全策略，现在所有支持 JavaScript 的浏览器都会使用这个策略。所谓同源是指协议，域名，端口相同，相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。</p>
<p>浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。比如一个恶意网站的页面通过iframe嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码。</p>
<h1 id="2-解决跨域"><a href="#2-解决跨域" class="headerlink" title="2. 解决跨域"></a>2. 解决跨域</h1><p>跨域影响：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 Js对象无法获得</li>
<li>AJAX 请求不能发送</li>
</ul>
<h2 id="1-CORS"><a href="#1-CORS" class="headerlink" title="1. CORS"></a>1. CORS</h2><p>跨域技术-CORS （CrossOrigin Resources Sharing，跨源资源共享），它是 HTML5 的一项特性，定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>浏览器将CORS请求分成两类：简单请求和非简单请求。</p>
<p>只要同时满足以下两大条件，就属于简单请求，反之，不满足以下条件的都属于复杂请求。</p>
<ol>
<li>请求方法是以下三种方法之一：<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</li>
<li>HTTP的头信息不超出以下几种字段：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ol>
<h3 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1. 简单请求"></a>1. 简单请求</h3><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。表明该请求来自哪个源，服务器根据这个值，决定是否同意这次请求：如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段（如下）。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，从而抛出错误。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同源允许，多出的几个头信息字段</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.baidu.com</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span></span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-非简单请求"><a href="#2-非简单请求" class="headerlink" title="2. 非简单请求"></a>2. 非简单请求</h3><p>非简单请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求，也就是我们常说的 OPTIONS 请求。服务器收到”预检”请求以后，检查Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认是否允许跨源请求。如果浏览器肯定了“预检”请求，就会返回一个正常的且带有CORS相关字段的回应，反之，如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预检通过，允许请求的回应</span></span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="built_in">Date</span>: Mon, <span class="number">01</span> Dec <span class="number">2008</span> <span class="number">01</span>:<span class="number">15</span>:<span class="number">39</span> GMT</span><br><span class="line">Server: Apache/<span class="number">2.0</span><span class="number">.61</span> (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.baidu.com       // 允许请求的源</span></span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT            <span class="comment">// 允许的请求方式</span></span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Keep-Alive: timeout=<span class="number">2</span>, max=<span class="number">100</span></span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-CORS-简单实现"><a href="#3-CORS-简单实现" class="headerlink" title="3. CORS 简单实现"></a>3. CORS 简单实现</h3><p>Node.js 实现 CORS 跨域请求</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> {origin, Origin, referer, Referer} = req.headers;</span><br><span class="line">    <span class="keyword">let</span> allowOrigin = origin || Origin || referer || Referer || <span class="string">'*'</span>;</span><br><span class="line"></span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Origin"</span>, allowOrigin);</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type, Authorization, X-Requested-With"</span>);</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="literal">true</span>);</span><br><span class="line">    res.header(<span class="string">"X-Powered-By"</span>, <span class="string">'Express'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) {</span><br><span class="line">        res.sendStatus(<span class="number">200</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        next();</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2. JSONP"></a>2. JSONP</h2><p>利用 script，img 等这些元素的开放策略，即不受同源策略的影响。其工作流程如下：</p>
<ul>
<li>声明一个回调函数(cb)，其函数名当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据data</li>
<li>创建一个 script 标签，把跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=cb）</li>
<li>服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是cb，它准备好的数据是cb({“name”:”aaaaaandy”}）。</li>
<li>最后服务器把准备的数据通过HTTP协议返回给客户端，同时修改返回头中’Content-Type’: ‘text/javascript’，则数据返回客户端后会马上执行之前声明的回调函数（cb），最后对返回的数据进行操作。</li>
</ul>
<p>需要注意的是：jsonp 只能实现 GET 请求而不能实现 POST 请求。</p>
<h2 id="3-nginx-代理"><a href="#3-nginx-代理" class="headerlink" title="3. nginx 代理"></a>3. nginx 代理</h2><p>利用 nginx 通过反向代理 满足浏览器的同源策略实现跨域，不需要目标服务器配合</p>
<p>将不同的域名转换成相同的就解决了跨域的问题，客户端发送请求时不直接到服务器而是先到代理的中间层，由中间层把请求源地址改为与服务器地址相同，当数据返回时，也是先经过中间层，将数据来源地址改为与客户端地址相同。这样就不受同源策略的影响。</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  b.com;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#请求跨域，这里约定代理请求url path是以/apis/开头</span></span><br><span class="line">        <span class="attribute">location</span><span class="regexp"> ^~/apis/</span> {</span><br><span class="line">            <span class="comment"># 这里重写了请求，将正则匹配中的第一个()中$1的path，拼接到真正的请求后面，并用break停止后续匹配</span></span><br><span class="line">            <span class="attribute">rewrite</span><span class="regexp"> ^/apis/(.*)$</span> /<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> https://www.baidu.com/;</span><br><span class="line">        }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还可以在nginx中添加头部实现跨域</p>
<figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  b.com;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 所有请求都会经过此location</span></span><br><span class="line">        <span class="attribute">location</span> /{</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">            <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) {</span><br><span class="line">                <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-websocket"><a href="#4-websocket" class="headerlink" title="4. websocket"></a>4. websocket</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，它本身允许跨域通讯，是server push技术的一种很好的实现。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">var</span> io = io.connect(<span class="string">'http://www.baidu.com'</span>);</span><br><span class="line">io.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server);</span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>{</span><br><span class="line">    client.emit(<span class="string">'data'</span>, <span class="string">'hello this is server'</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<h2 id="5-postMessage"><a href="#5-postMessage" class="headerlink" title="5. postMessage"></a>5. postMessage</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。也就是说，它实现的是不同页面之间的通讯。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1.html</span><br><span class="line"><span class="tag"><<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://www.a.com/1.html"</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>></span><span class="tag"></<span class="name">iframe</span>></span></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span>       </span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="actionscript">    iframe.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> data = {</span></span><br><span class="line"><span class="actionscript">            name: <span class="string">'test postmessage'</span></span></span><br><span class="line">        };</span><br><span class="line"><span class="actionscript">        <span class="comment">// 向domain b传送跨域数据</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.b.com'</span>);</span></span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 监听message，接受domain b返回数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"><span class="actionscript">    }, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 2.html</span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 监听message，接收domain a的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>{</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line">        if (data) {</span><br><span class="line"><span class="actionscript">            <span class="comment">// 向domain a发送数据</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.a.com'</span>);</span></span><br><span class="line">        }</span><br><span class="line"><span class="actionscript">    }, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="6-window-name"><a href="#6-window-name" class="headerlink" title="6. window.name"></a>6. window.name</h2><p>当在浏览器中打开一个页面，或者在页面中添加一个iframe时即会创建一个对应的window对象，当页面加载另一个新的页面时，window的name属性是不会变的。这样就可以利用在页面动态添加一个iframe然后src加载数据页面，在数据页面将需要的数据赋值给window.name。然而此时承载iframe的parent页面还是不能直接访问，不在同一域下iframe的name属性，这时只需要将iframe再加载一个与承载页面同域的空白页面，即可对window.name进行数据读取。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// localhost:8088/2.html</span><br><span class="line"><span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> person = {</span></span><br><span class="line"><span class="actionscript">      name: <span class="string">'yuan wang'</span>,</span></span><br><span class="line">      age: 21</span><br><span class="line">    }</span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="built_in">JSON</span>.stringify(person)</span></span><br><span class="line"><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// localhost:8081/1.html</span><br><span class="line"><span class="tag"><<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8088/2.html"</span> <span class="attr">frameborder</span>=<span class="string">"1"</span>></span><span class="tag"></<span class="name">iframe</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">script</span>></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ifr = <span class="built_in">document</span>.querySelector(<span class="string">'iframe'</span>)</span></span><br><span class="line"><span class="actionscript">    ifr.style.display = <span class="string">'none'</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> flag = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    ifr.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{</span></span><br><span class="line">        if (flag == 1) {</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(ifr.contentWindow.name);        <span class="comment">// 跨域获取数据</span></span></span><br><span class="line">            ifr.contentWindow.close();</span><br><span class="line"><span class="actionscript">        } <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">0</span>) {</span></span><br><span class="line">            flag = 1;</span><br><span class="line"><span class="actionscript">            ifr.contentWindow.location = <span class="string">'http://localhost:8081/proxy.html'</span>;</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  <span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure>

<p>这里是使用iframe将2.html加载过来，因为只是为了实现跨域，所以将之隐藏，但是，这时已经完成了最重要的一步，就是将iframe中window.name已经成功设置，但是现在还获取不了，因为是跨域的，所以，我们可以把src设置为当前域的proxy.html。</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// proxy.html 其实就是一个空白页面</span><br><span class="line"><span class="meta"><!DOCTYPE <span class="meta-keyword">html</span>></span></span><br><span class="line"><span class="tag"><<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>></span></span><br><span class="line"><span class="tag"><<span class="name">head</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">title</span>></span>proxy<span class="tag"></<span class="name">title</span>></span></span><br><span class="line"><span class="tag"></<span class="name">head</span>></span></span><br><span class="line"><span class="tag"><<span class="name">body</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">p</span>></span>proxy页面<span class="tag"></<span class="name">p</span>></span></span><br><span class="line"><span class="tag"></<span class="name">body</span>></span></span><br><span class="line"><span class="tag"></<span class="name">html</span>></span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="7-document-domain"><a href="#7-document-domain" class="headerlink" title="7. document.domain"></a>7. document.domain</h2><p>这种方式只适合主域名相同，但子域名不同的iframe跨域。比如主域名是<a href="http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain">http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain</a> = crossdomain.com就可以访问各自的window对象了。</p>
<a id="more"></a>
</body></html>
    </div>
</article>
        </main>
    </div>
</body>

</html>
