<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta name="keywords" content="hexo, andy" />
    <title>
        aaaaaAndy
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="img/favicon.ico" />
     
<link rel="stylesheet" href="/blog/css/style.css">


    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" />
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
<!--    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>-->

    <script>
        // infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/blog/" class="logo">
                aaaaaAndy
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/blog/" class="logo">
            aaaaaAndy
        </a>
    </h1>
    <h2 class="desc">
        
    </h2>

    <div class="links">
        <ul id="menu-inner" class="menu-inner">
            
            <li class="menu-inner-item">
                <a href="/blog/">
                    Home
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/category">
                    Category
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/tag">
                    Tag
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/about">
                    About
                </a>
            </li>
            
        </ul>
    </div>
</header>

        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/blog/categories/JavaScript/">
            JavaScript
        </a>
    </h4>
    
    
    <h2 class="post-title">
        简单实现一个EventEmitter
    </h2>
    <ul class="post-date">
        <li>
            2019-03-12
        </li>
        <li>
            aaaaaAndy
        </li>
    </ul>
    <div class="post-content">
        <p>EventEmitter 是 NodeJS 的核心模块 events 中的类，用于对 NodeJS 中的事件进行统一管理，用 events 特定的 API 对事件进行添加、触发和移除等等，核心方法的模式类似于发布订阅</p>
<h2 id="1-Node-中的-EventEmitter"><a href="#1-Node-中的-EventEmitter" class="headerlink" title="1. Node 中的 EventEmitter"></a>1. Node 中的 EventEmitter</h2><p>EventEmitter本质上是一个观察者模式的实现。</p>
<p>观察者模式：<strong><em>它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</em></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node 中的 EventEmitter 简单用法</span></span><br><span class="line"><span class="keyword">let</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">let</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">'show'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is show callback'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">eventEmitter.emit(<span class="string">'show'</span>);</span><br></pre></td></tr></table></figure>

<p>eventEmitter是EventEmitter模块的一个实例，eventEmitter的emit方法，发出show事件，通过eventEmitter的on方法监听，从而执行相应的函数。</p>
<h2 id="2-简单实现一个-EventEmitter"><a href="#2-简单实现一个-EventEmitter" class="headerlink" title="2. 简单实现一个 EventEmitter"></a>2. 简单实现一个 EventEmitter</h2><p>接下来我们简单实现一个EventEmitter模块的基础功能emit和on。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>._events = &#123;&#125;;      <span class="comment">// 保存事件</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加事件监听</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;String&#125;</span>   </span>eventName 监听的对象名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>callback  事件处理函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  on (eventName, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events[eventName]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[eventName] = [];     <span class="comment">// 每个监听的对象，要处理的事件存放在一个数组里</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>._events[eventName].push(callback);     <span class="comment">// 添加监听事件</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触发事件监听函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;String&#125;</span>    </span>eventName 监听的对象名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param  <span class="type">&#123;...[type]&#125;</span> </span>args      传入的参数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  emit (eventName, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events[eventName]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._events[eventName].length; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>._events[eventName][i](...args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除事件监听</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="variable">eventName</span></span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  off (eventName, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[eventName] = <span class="keyword">this</span>._events[eventName].filter(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== callback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._events[eventName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 只执行一次事件监听</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="variable">eventName</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="variable">callback</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  once (eventName, callback) &#123;</span><br><span class="line">    <span class="keyword">let</span> onceFun = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      callback.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      <span class="keyword">this</span>.off(eventName, onceFun);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.on(eventName, onceFun);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-EventEmitter-模块的异常处理"><a href="#3-EventEmitter-模块的异常处理" class="headerlink" title="3. EventEmitter 模块的异常处理"></a>3. EventEmitter 模块的异常处理</h2><p>为什么要添加异常处理模块？因为node中有一个特殊的事件error，如果异常没有被捕获，就会触发 process 的 uncaughtException 事件抛出，如果没有注册该事件的监听器，则 Node.js 会在控制台打印该异常的堆栈信息，并结束进程。</p>
<h3 id="1-try…catch-方法"><a href="#1-try…catch-方法" class="headerlink" title="1. try…catch 方法"></a>1. try…catch 方法</h3><p>通过 try…catch 可以来捕获错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> x = x;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，赋值语句的错误会被捕获，但是<strong><em>try…catch不能捕获非阻塞或者异步函数里的异常</em></strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> x = x;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，因为process.nextTick是异步的，因此在process.nextTick内部的错误不能被捕获。</p>
<h3 id="2-process-on-‘uncaughtException’-方法"><a href="#2-process-on-‘uncaughtException’-方法" class="headerlink" title="2. process.on(‘uncaughtException’) 方法"></a>2. process.on(‘uncaughtException’) 方法</h3><p>node中提供了一个最外层的兜底的捕获异常的方法。非阻塞或者异步函数中的异常都会抛出到最外层，如果异常没有被捕获，那么会暴露出来，被最外层的process.on(‘uncaughtException’)所捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> x = x; <span class="comment">//第二个x在使用前未定义，会抛出异常</span></span><br><span class="line">  &#125;,<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'该异常已经被捕获'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;<span class="built_in">console</span>.log(err)&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-EventEmitter-源码实现"><a href="#4-EventEmitter-源码实现" class="headerlink" title="4. EventEmitter 源码实现"></a>4. EventEmitter 源码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * EventEmitter 构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventEmitter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//私有属性，保存订阅方法</span></span><br><span class="line">  <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认最大监听数</span></span><br><span class="line">EventEmitter.defaultMaxListeners = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * on方法，该方法用于订阅事件，在旧版本的node.js中是addListener方法，它们是同一个函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>type       监听的对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>listener 监听的回调函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Boolean&#125;</span> </span>flag      是否先于其他同类监听事件执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventEmitter.prototype.on = EventEmitter.prototype.addListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener, flag</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//保证存在实例属性</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events) <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;     <span class="comment">//从头部插入</span></span><br><span class="line">            <span class="keyword">this</span>._events[type].unshift(listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>._events[type].push(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>._events[type] = [listener];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//绑定事件，触发newListener</span></span><br><span class="line">    <span class="keyword">if</span> (type !== <span class="string">'newListener'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'newListener'</span>, type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * emit方法: 将订阅方法取出执行，使用call方法来修正this的指向，使其指向子类的实例。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;String&#125;</span>    </span>type 监听的对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;...[type]&#125;</span> </span>args 参数传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventEmitter.prototype.emit = <span class="function"><span class="keyword">function</span> (<span class="params">type, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events[type]) &#123;</span><br><span class="line">        <span class="keyword">this</span>._events[type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn.call(<span class="keyword">this</span>, ...args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * once方法，它的功能是将事件订阅“一次”，当这个事件触发过就不会再次触发了。</span></span><br><span class="line"><span class="comment"> * 其原理是将订阅的方法再包裹一层函数，在执行后将此函数移除即可。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;String&#125;</span> </span>type     监听的对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>listener 监听的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 中间函数，在调用完之后立即删除订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">only</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        listener();</span><br><span class="line">        _this.removeListener(type, only);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// origin保存原回调的引用，用于remove时的判断</span></span><br><span class="line">    only.origin = listener;</span><br><span class="line">    <span class="keyword">this</span>.on(type, only);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * off方法即为退订，原理同观察者模式一样，将订阅方法从数组中移除即可。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;String&#125;</span>   </span>type     监听的对象名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param  <span class="type">&#123;Function&#125;</span> </span>listener 监听的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventEmitter.prototype.off = EventEmitter.prototype.removeListener = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._events[type]) &#123;</span><br><span class="line">        <span class="comment">// 过滤掉退订的方法，从数组中移除</span></span><br><span class="line">        <span class="keyword">this</span>._events[type] = <span class="keyword">this</span>._events[type].filter(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn !== listener &amp;&amp; fn.origin !== listener</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

    </div>
</article>
        </main>
    </div>
</body>

</html>
