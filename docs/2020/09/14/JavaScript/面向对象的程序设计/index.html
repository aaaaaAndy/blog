<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="面向对象的程序设计   理解对象   常见创建对象方式  1. 创建一个 Object 实例  1 2 3 4 5 6 7   var person &#x3D; new Object(); person.name &#x3D; &#39;andy&#39;; person.age &#x3D; 12;  person.sayName &#x3D; function() {   console.log(this.name); }   2. 对象字面量">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象的程序设计">
<meta property="og:url" content="https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="aaaaaAndy">
<meta property="og:description" content="面向对象的程序设计   理解对象   常见创建对象方式  1. 创建一个 Object 实例  1 2 3 4 5 6 7   var person &#x3D; new Object(); person.name &#x3D; &#39;andy&#39;; person.age &#x3D; 12;  person.sayName &#x3D; function() {   console.log(this.name); }   2. 对象字面量">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-09-14T02:17:20.000Z">
<meta property="article:modified_time" content="2020-09-14T08:35:41.353Z">
<meta property="article:author" content="aaaaaAndy">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="面向对象">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/blog/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/blog/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>面向对象的程序设计</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/blog/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" class="active" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" class="active" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu" style="visibility: visible;">
    <span id="nav">
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/category">Category</a></li>
         
          <li><a href="/blog/tag">Tag</a></li>
         
          <li><a href="/blog/about">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/blog/2020/09/17/react%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E5%9F%BA%E7%A1%80-ReactAPI/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/blog/2020/08/22/JavaScript/IntersectionObserver-%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&text=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&is_video=false&description=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=面向对象的程序设计&body=Check out this article: https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&name=面向对象的程序设计&description=面向对象的程序设计


理解对象


常见创建对象方式

1. 创建一个 Object 实例

1
2
3
4
5
6
7


var person = new Object();
person.name = &#39;andy&#39;;
person.age = 12;

person.sayName = function() {
  console.log(this.name);
}


2. 对象字面量

1
2
3
4
5
6
7
8


var person = {
  name: &#39;andy&#39;,
  age: 12,
  
  sayName: function() {
    console."><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象的程序设计"><span class="toc-number">1.</span> <span class="toc-text">面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#理解对象"><span class="toc-number">1.1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见创建对象方式"><span class="toc-number">1.1.1.</span> <span class="toc-text">常见创建对象方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-创建一个-Object-实例"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1. 创建一个 Object 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-对象字面量"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2. 对象字面量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">属性类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据属性"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问器属性"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">访问器属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-number">1.2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-工厂模式"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.  工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造函数模式"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-原型模式"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#"><span class="toc-number">1.2.3.0.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#判断属性是来自于原型还是实例"><span class="toc-number">1.2.3.0.2.</span> <span class="toc-text">判断属性是来自于原型还是实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-组合使用构造函数模式和原型模式"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-动态原型模式"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-寄生构造函数模式"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. 寄生构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-稳妥构造函数模式"><span class="toc-number">1.2.7.</span> <span class="toc-text">7. 稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">1.3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-原型链实现继承"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 原型链实现继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造函数继承"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-组合继承"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-原型式继承"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-寄生式继承"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-寄生组合式继承"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 寄生组合式继承</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        面向对象的程序设计
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">aaaaaAndy</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-09-14T02:17:20.000Z" itemprop="datePublished">2020-09-14</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/blog/tags/JavaScript/" rel="tag">JavaScript</a>, <a class="tag-link" href="/blog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="常见创建对象方式"><a href="#常见创建对象方式" class="headerlink" title="常见创建对象方式"></a>常见创建对象方式</h3><h4 id="1-创建一个-Object-实例"><a href="#1-创建一个-Object-实例" class="headerlink" title="1. 创建一个 Object 实例"></a>1. 创建一个 <code>Object</code> 实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">'andy'</span>;</span><br><span class="line">person.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-对象字面量"><a href="#2-对象字面量" class="headerlink" title="2. 对象字面量"></a>2. 对象字面量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'andy'</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  </span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><blockquote>
<p>ECMA-262 第5版在定义只有内部采用的特性时,描述了属性的各种特征, ECMA-262定义这些特性是为了实现JavaScript引擎用的,因此在JavaScript中不能直接访问它们.</p>
</blockquote>
<p>ECMAScript中有两种属性: <strong><em>数据属性</em></strong> 和 <strong><em>访问器属性</em></strong></p>
<h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><ul>
<li>[[<strong>Configurable</strong>]]: 表示能否通过<code>delete</code>删除属性从而重新定义属性, 默认<code>true</code></li>
<li>[[<strong>Enumerable</strong>]]: 表示能否通过 <code>for-in</code> 循环返回属性, 默认<code>true</code></li>
<li>[[<strong>Writable</strong>]]: 表示能否修改属性的值, 默认<code>true</code></li>
<li>[[<strong>Value</strong>]]: 包含这个属性的数据值. 读取属性值的时候, 从这个位置读,写入时, 把新值保存在这个位置,默认<code>undefined</code></li>
</ul>
<p>要修改属性默认的特性, 必须使用ECMAScript 5的<code>Object.defineProperty()</code>方法.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'andy'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name): <span class="comment">// andy</span></span><br><span class="line">person.name = <span class="string">'qiqi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name): <span class="comment">// andy</span></span><br></pre></td></tr></table></figure>

<p>该属性的值配置为不可修改, 如果尝试为它指定新值,在非严格模式下,赋值操作会被忽略,在严格模式下,赋值操作将会导致抛出错误.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">'andy'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">OBject.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">'andy'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也就是说, 可以多次调用<code>Object.defineProperty()</code>方法修改同一个属性,但在把<code>configurable</code>特性设置为false之后就会有限制了.</p>
<p>*<u>IE8是第一个实现<code>Object.defineProperty()</code>方法 的浏览器版本.然而这个版本存在诸多限制:所以不建议使用.</u>*</p>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>访问器属性不包含数据值, 它们包含一对儿<code>getter</code>和<code>setter</code>函数,在读取访问器属性时,会调用<code>getter</code>函数, 这个函数负责返回有效的值,在写入访问器属性时,会调用<code>setter</code>函数并传入新值.</p>
<ul>
<li>[[<strong>Configurable</strong>]]: 表示能否通过<code>delete</code>删除属性从而重新定义属性, 默认<code>true</code></li>
<li>[[<strong>Enumerable</strong>]]: 表示能否通过 <code>for-in</code> 循环返回属性, 默认<code>true</code></li>
<li>[[<strong>Get</strong>]]: 在读取属性时调用的函数,默认值<code>undefined</code></li>
<li>[[<strong>Set</strong>]]: 在写入属性时调用的函数, 默认值为<code>undefined</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year: <span class="number">2004</span>,</span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book, <span class="string">'year'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>._year = newValue;</span><br><span class="line">    <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition): <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>以上代码指定了<code>book</code>对象中<code>year</code>属性的访问器属性, 其实也不一定要同时制定<code>getter</code>和<code>setter</code>, 只指定<code>getter</code>意味着属性是不能写,只指定<code>setter</code>意味着属性不能读.</p>
<p><code>Object.defineProperties()</code>: 利用这个方法可以通过描述符一次定义多个属性.</p>
<p><code>Object.getOwnPropertyDescriptor()</code>: 取得给定属性功能的描述符.</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.  工厂模式"></a>1.  工厂模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = createPerson(<span class="string">'andy'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>如上所示,工厂模式通过传入参数来赋值给对象相应的属性, 从而返回相似的对象, 这种模式虽然解决了多个相似对象的问题, 但是没有解决对象识别的问题(即怎样知道一个对象的类型);</p>
<h3 id="2-构造函数模式"><a href="#2-构造函数模式" class="headerlink" title="2. 构造函数模式"></a>2. 构造函数模式</h3><p><code>ECMAScript</code>中的构造函数可用来创建特定类型的对象.像Object和Array这样的原生构造函数, 在运行时会自动出现在执行环境中,此外,也可以创建自定义的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'andy'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'qiqi'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>要创建<code>Person</code>的新实例,必须使用<code>new</code>操作符,以这种方式调用构造函数实际上会经历以下四个步骤</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域给新对象(因此<code>this</code>就指向了这个新对象)</li>
<li>执行构造函数中的代码(为这个新对象添加属性)</li>
<li>返回新对象</li>
</ol>
<p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型, 而这正是构造函数模式胜过工厂模式的地方.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.sayName === person2.sayName; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>构造函数的问题: 使用构造函数的主要问题,就是每个方法都要在每个实例上重新创建一遍. 但是创建两个完成同样任务的Function实例的确没有必要,况且有this对象在,根本不用在执行代码前就把函数绑定到特定的对象上面.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'andy'</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">'qiqi'</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中,我们把<code>sayName()</code>函数的定义转移到了构造函数外部.而在构造函数内部,我们将<code>sayName</code>属性设置成全局的sayName函数, 这样以来,就解决了方法的实例重复创建的问题, 但是当这样的全局函数变多时, 将会对全局变量造成污染.</p>
<h3 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3. 原型模式"></a>3. 原型模式</h3><p>我们创建的每个函数都有一个 <code>prototype</code>属性,这个属性时一个指针, 指向一个对象,而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法. 我们可以将这些信息添加到原型对象中,从而实现共享.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">'andy'</span>;</span><br><span class="line">Person.prototype.age = <span class="number">12</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>这样实现的问题在于它们的原型对象时共享的, 即<code>person1</code>和<code>person2</code>访问的都是同一组属性和同一个<code>sayName()</code>函数.</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="判断属性是来自于原型还是实例"><a href="#判断属性是来自于原型还是实例" class="headerlink" title="判断属性是来自于原型还是实例"></a>判断属性是来自于原型还是实例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  该方法可用来判断name属性是来自于原型上的还是实例上的.</span></span><br><span class="line">person1.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要能通过原型链找到就返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(name <span class="keyword">in</span> person1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p>Example: 判断来自于原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypePtoperty</span>(<span class="params">object, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !<span class="built_in">Object</span>.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-组合使用构造函数模式和原型模式"><a href="#4-组合使用构造函数模式和原型模式" class="headerlink" title="4. 组合使用构造函数模式和原型模式"></a>4. 组合使用构造函数模式和原型模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'anqi'</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>这种构造函数与原型混成的模式, 是目前在<code>ECMAScript</code>中使用最广泛, 认同度最高的一种创建自定义类型的方法. 可以说, 这是用来定义饮用类型的一种默认模式.</p>
<h3 id="5-动态原型模式"><a href="#5-动态原型模式" class="headerlink" title="5. 动态原型模式"></a>5. 动态原型模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">'function'</span>) &#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'andy'</span>, <span class="number">12</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure>

<p>这里只在<code>sayName()</code>方法不存在的情况下, 才会将它添加到原型中.这段代码只会在初次调用构造函数时才会执行.此后, 原型已经出实话,不需要再做什么修改了.</p>
<h3 id="6-寄生构造函数模式"><a href="#6-寄生构造函数模式" class="headerlink" title="6. 寄生构造函数模式"></a>6. 寄生构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'andy'</span>, <span class="number">12</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure>

<p>这种模式的思想是创建一个函数, 该函数的作用仅仅是封装对象的代码,然后再返回新创建的对象; 在这里例子中,除了使用<code>new</code>操作符并把使用的包装函数叫做构造函数之外, 这个模式跟工厂模式其实是一摸一样的.构造函数在不返回值的情况下,默认会返回新对象实例.而通过在构造函数的末尾添加一个<code>return</code>语句,可以重写调用构造函数时返回的值.</p>
<p>这个模式可以在特殊的情况下用来为对象创建构造函数,假设我们想创建一个具有额外方法的特殊数组,由于不能直接修改<code>Array</code></p>
<p>构造函数,因此可以使用这个模式.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">  values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">  values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">'|'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipedString()); <span class="comment">// red|blud|green</span></span><br></pre></td></tr></table></figure>

<h3 id="7-稳妥构造函数模式"><a href="#7-稳妥构造函数模式" class="headerlink" title="7. 稳妥构造函数模式"></a>7. 稳妥构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意,以这种模式创建的对象中, 除了使用<code>sayName()</code>方法之外,没有其他办法访问<code>name</code>的值.这种模式适合用于一些比较安全的环境中, 不能使用<code>this</code>和<code>new</code>.</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="1-原型链实现继承"><a href="#1-原型链实现继承" class="headerlink" title="1. 原型链实现继承"></a>1. 原型链实现继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(aa.getSuperValue());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>原型链虽然强大,可以用它来实现继承,但它也存在一些问题.其中,最主要的问题来自包含引用类型值的原型, 引用类型值的原型属性会被所有实例共享,而这也正是为什么要在构造函数中,而不是在原型对象中定义属性的原因.在通过原型来实现继承时,原型实际上会变成另一个类型的实例,于是,原先的实例属性也就顺理成章的变成了现在的原型属性了.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// red,blue,green,black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// red,blud,green,black</span></span><br></pre></td></tr></table></figure>

<p>原型链的第二个问题时: 在创建子类型的实例时,不能向超类型的构造函数中传递参数.实际上,应该说时没有办法在不影响所有对象实例的情况下, 给超类型的构造函数传递参数.</p>
<h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h3><p>这种技术的基本思想相当简单,即在子类型构造函数的内部调用超类型构造函数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// red,blue,green,black</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// red,blud,green</span></span><br></pre></td></tr></table></figure>

<p>借用构造函数模式, 还可以实现子类型构造函数中向超类型构造函数传递参数.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">'andy'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name); <span class="comment">// andy</span></span><br><span class="line"><span class="built_in">console</span>.log(instance age); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>如果仅仅是借用构造函数,那么无法避免构造函数模式存在的问题——方法都在构造函数中定义,因此函数复用也就无从谈起了.而且超类型原型中国呢定义的方法, 对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式.</p>
<h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><p>组合继承,有时候也叫做伪经典继承,指的是将原型链和构造函数继承的结束和到一起,从而发挥二者之长的一种继承模式. 其背后的思路是使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承, 这样, 既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blud'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'andy'</span>, <span class="number">12</span>);</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors); <span class="comment">// red,blue,greem,black</span></span><br><span class="line">instance1.sayName(); <span class="comment">// andy</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'qiqi'</span>, <span class="number">11</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors); <span class="comment">// red,blue,green</span></span><br><span class="line">instance2.sayName(); <span class="comment">// qiqi</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>继承组合避免了原型链和借用构造函数的缺陷,融合了它们的优点,成为<code>JavaScript</code>中最常用的继承模式.而且,<code>instanceof</code>和isP <code>rototypeOf()</code>也能够用于识别基于组合继承创建的对象.</p>
<h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h3><p>该模式的思想是: 原型可以基于已有的对象创建新对象,同时还不比因此创建自定义类型.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'andy'</span>,</span><br><span class="line">  age: <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = object(person);</span><br><span class="line"><span class="keyword">var</span> bb = object(person);</span><br></pre></td></tr></table></figure>

<p><code>person</code>是<code>aa</code>对象的基础,也就是说<code>person</code>是<code>aa</code>对象的原型,通过这种方式实现的继承,它们的原型是共享的, 也就是说<code>aa</code>和<code>bb</code>的原型是相同的,这与原型链实现继承效果是相似的.</p>
<p>ECMAScript 5通过新增<code>Object.create()</code>方法规范了原型式继承,这个方法接收两个参数,一个用作新对象原型, 一个为新对象定义额外属性的对象,在传入一个参数的情况下, Object.create()与object()方法的行为相同.</p>
<p>在没有必要兴师动众地创建构造函数,而只想让一个对象与另一个对象保持类似的情况下,原型式继承式完全可以胜任的, 不过,包含引用类型值的属性是中都会共享相应的值,就像使用原型模式一样.</p>
<h3 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h3><p>寄生式继承是与原型式继承紧密相关的一种思路,寄生式继承的思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该函数在内部以·某种方式来增强对象,最后再像真的式它做了所有工作一样返回对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(original);</span><br><span class="line">  </span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'andy'</span>,</span><br><span class="line">  age: <span class="number">12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>在主要考虑对象而不是自定义类型和构造函数的情况下,寄生式继承也是一种有用的模式.</p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subtype, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype);</span><br><span class="line">  prototype.constructor = superType;</span><br><span class="line">  subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子的高效率体现在它只调用了一次<code>SuperType</code>构造函数,并且因此避免了在<code>SubType.prototype</code>上创建不必要的,多余的属性,与此同时,原型链还能保持不变,还能够正常使用<code>instanceof</code>和<code>isPrototypeOf()</code></p>
<p>这是引用类型最理想的继承方式.</p>
<a id="more"></a>
  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/category">Category</a></li>
         
          <li><a href="/blog/tag">Tag</a></li>
         
          <li><a href="/blog/about">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象的程序设计"><span class="toc-number">1.</span> <span class="toc-text">面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#理解对象"><span class="toc-number">1.1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见创建对象方式"><span class="toc-number">1.1.1.</span> <span class="toc-text">常见创建对象方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-创建一个-Object-实例"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1. 创建一个 Object 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-对象字面量"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2. 对象字面量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性类型"><span class="toc-number">1.1.2.</span> <span class="toc-text">属性类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据属性"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问器属性"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">访问器属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-number">1.2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-工厂模式"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.  工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造函数模式"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-原型模式"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#"><span class="toc-number">1.2.3.0.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#判断属性是来自于原型还是实例"><span class="toc-number">1.2.3.0.2.</span> <span class="toc-text">判断属性是来自于原型还是实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-组合使用构造函数模式和原型模式"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-动态原型模式"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-寄生构造函数模式"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. 寄生构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-稳妥构造函数模式"><span class="toc-number">1.2.7.</span> <span class="toc-text">7. 稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">1.3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-原型链实现继承"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 原型链实现继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-构造函数继承"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-组合继承"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-原型式继承"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-寄生式继承"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-寄生组合式继承"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 寄生组合式继承</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&text=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&is_video=false&description=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=面向对象的程序设计&body=Check out this article: https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&title=面向对象的程序设计" target="_blank" rel="noopener"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://aaaaaandy.github.io/2020/09/14/JavaScript/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/&name=面向对象的程序设计&description=面向对象的程序设计


理解对象


常见创建对象方式

1. 创建一个 Object 实例

1
2
3
4
5
6
7


var person = new Object();
person.name = &#39;andy&#39;;
person.age = 12;

person.sayName = function() {
  console.log(this.name);
}


2. 对象字面量

1
2
3
4
5
6
7
8


var person = {
  name: &#39;andy&#39;,
  age: 12,
  
  sayName: function() {
    console."><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 aaaaaAndy
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/category">Category</a></li>
         
          <li><a href="/blog/tag">Tag</a></li>
         
          <li><a href="/blog/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/blog/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/blog/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/blog/lib/jquery/jquery.min.js"></script>


<script src="/blog/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/blog/js/main.js"></script>





