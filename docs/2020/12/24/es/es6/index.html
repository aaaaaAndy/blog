<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
    <meta name="keywords" content="hexo, andy" />
    <title>
        aaaaaAndy
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="img/favicon.ico" />
     
<link rel="stylesheet" href="/blog/css/style.css">


    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css" />
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
<!--    <script src="https://cdn.jsdelivr.net/gh/frontendsophie/hexo-infinite-scroll@2.0.0/dist/main.js"></script>-->

    <script>
        // infiniteScroll()

        window.addEventListener('DOMContentLoaded', function () {
            const [
                mainTitle,
                mobileMenu,
                mobileMainTitle,
                mobileMenuBtn,
                ipadMenuBtn,
                aside,
                closeBtn,
            ] = getEle(
                '#main-title',
                '.mobile-menu',
                '.mobile-menu h3',
                '.mobile-menu button',
                '.ipad-menu',
                'aside',
                'aside .close',
            )
            const io = new IntersectionObserver(entries => {
                if (entries[0].intersectionRatio <= 0) {
                    mobileMainTitle.classList.remove('invisibile')
                } else {
                    mobileMainTitle.classList.add('invisibile')
                }
            })
            io.observe(mainTitle)

            clickToggleAside(mobileMenuBtn)
            clickToggleAside(ipadMenuBtn)
            clickToggleAside(closeBtn, false)

            const isMenuVisible = window.getComputedStyle(mobileMenu).display !== 'none'
            if (isMenuVisible) document.body.style.background = 'none'

            function getEle(...args) {
                return args.map(arg => document.querySelector(arg))
            }

            function clickToggleAside(btn, show = true) {
                btn.addEventListener('click', function () {
                    if (show) {
                        aside.style.display = 'block'
                    } else {
                        aside.style.display = 'none'
                    }
                })
            }
        })
    </script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
    <div class="container">
        <header class="header">
    <nav class="mobile-menu" style="background: url(https://cdn.jsdelivr.net/gh/frontendsophie/hexo-theme-autumn@1.0.0/source/img/button-bg.png) #f3f3f3">
        <h3 class="invisibile">
            <a href="/blog/" class="logo">
                aaaaaAndy
            </a>
        </h3>
        <button class="menu">menu</button>
    </nav>

    <button class="ipad-menu menu">menu</button>

    <h1 class="title" id="main-title">
        <a href="/blog/" class="logo">
            aaaaaAndy
        </a>
    </h1>
    <h2 class="desc">
        
    </h2>

    <div class="links">
        <ul id="menu-inner" class="menu-inner">
            
            <li class="menu-inner-item">
                <a href="/blog/">
                    Home
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/category">
                    Category
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/tag">
                    Tag
                </a>
            </li>
            
            <li class="menu-inner-item">
                <a href="/blog/about">
                    About
                </a>
            </li>
            
        </ul>
    </div>
</header>

        <main class="main">
            <article class="post">
    
    
    <h4 class="post-cat">
        <a href="/blog/categories/ES/">
            ES
        </a>
    </h4>
    
    
    <h2 class="post-title">
        es6
    </h2>
    <ul class="post-date">
        <li>
            2020-12-24
        </li>
        <li>
            aaaaaAndy
        </li>
    </ul>
    <div class="post-content">
        <html><head></head><body><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="1-let和const"><a href="#1-let和const" class="headerlink" title="1. let和const"></a>1. <code>let</code>和<code>const</code></h2><p><code>var</code>是传统上的函数作用域。ES6<code>推荐使用</code>let<code>声明局部变量，</code>const`声明常量，两者都为块级作用域。</p>
<ol>
<li><p><code>let</code>用法</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'andy'</span>;</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// let声明局部变量</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'qiqi'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(name);  <span class="comment">// qiqi</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// andy</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>const</code>用法</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'andy'</span>;</span><br><span class="line">name = <span class="string">'qiqi'</span>;  <span class="comment">// 报错，不可被修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = { <span class="attr">name</span>: <span class="string">'andy'</span> };</span><br><span class="line">person.name = <span class="string">'qiqi'</span>;  <span class="comment">// 可以被修改</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<p>由<code>const</code>声明的变量都会被认为是常量，即它的值被设置完成后就不能再修改了，但是如果<code>const</code>是一个对象，对象所包含的值是可以被修改的。抽象点说，就是对象所指向的地址没有变。</p>
<p>以下几点需要注意：</p>
<ul>
<li><code>let</code>关键字声明的变量不具备变量提升特性；</li>
<li><code>let</code>和<code>const</code>声明只在最靠近的一个块中有效；</li>
<li><code>const</code>在声明时必须被赋值</li>
</ul>
<h2 id="2-函数相关"><a href="#2-函数相关" class="headerlink" title="2. 函数相关"></a>2. 函数相关</h2><h3 id="2-1-箭头函数"><a href="#2-1-箭头函数" class="headerlink" title="2.1 箭头函数"></a>2.1 箭头函数</h3><blockquote>
<p>  ES6中，箭头函数是函数的一种简写形式。使用括号包裹参数，跟随一个 =>，紧接着是函数体；</p>
</blockquote>
<p>箭头函数的三个特点：</p>
<ul>
<li>不需要<code>function</code>关键字来创建函数</li>
<li>可以省略<code>return</code>关键字</li>
<li>没有自己的<code>this</code>，继承当前上下文的<code>this</code></li>
</ul>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =></span> x + <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-2-函数默认值"><a href="#2-2-函数默认值" class="headerlink" title="2.2 函数默认值"></a>2.2 函数默认值</h3><p>在参数括号内直接设置默认值</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name = <span class="string">'andy'</span>, age = <span class="number">12</span></span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-3-Spread-Rest操作符"><a href="#2-3-Spread-Rest操作符" class="headerlink" title="2.3 Spread/Rest操作符"></a>2.3 <code>Spread/Rest</code>操作符</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// restParams代表剩下所有的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">a, b, ...restParams</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(restParams);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">print(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h2><p>在<code>ES6</code>之前我们用<code>+</code>来拼接字符串，但是在<code>ES6</code>中，可以使用``反引号来使用模板字符串</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'andy'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="string">'12'</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="string">'我是'</span> + name + <span class="string">'我今年'</span> + age + <span class="string">'岁了'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'andy'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="string">'12'</span>;</span><br><span class="line"><span class="keyword">const</span> person = <span class="string">`我是<span class="subst">${name}</span>我今年<span class="subst">${age}</span>岁了`</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-对象和数组的解构"><a href="#4-对象和数组的解构" class="headerlink" title="4. 对象和数组的解构"></a>4. 对象和数组的解构</h2><ol>
<li><p>对象解构</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = {</span><br><span class="line">  name: <span class="string">'andy'</span>,</span><br><span class="line">  age: <span class="number">11</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> { name, age } = person;</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// andy;</span></span><br><span class="line"><span class="built_in">console</span>.log(age):  <span class="comment">// 12;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>数组解构</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> persons = [<span class="string">'andy'</span>, <span class="string">'qiqi'</span>];</span><br><span class="line"><span class="keyword">const</span> [boy, girl] = persons;</span><br><span class="line"><span class="built_in">console</span>.log(boy);  <span class="comment">// andy;</span></span><br><span class="line"><span class="built_in">console</span>.log(girl);  <span class="comment">// qiqi;</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="5-for-in和for-of"><a href="#5-for-in和for-of" class="headerlink" title="5. for...in和for...of"></a>5. <code>for...in</code>和<code>for...of</code></h2><ol>
<li><p><code>for...in</code>：用来遍历对象中的属性</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的遍历</span></span><br><span class="line"><span class="keyword">const</span> person = {</span><br><span class="line">  name: <span class="string">'andy'</span>,</span><br><span class="line">  age: <span class="number">12</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> person) {</span><br><span class="line">  <span class="built_in">console</span>.log(key);  <span class="comment">// name, age</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的遍历</span></span><br><span class="line"><span class="keyword">const</span> ages = [<span class="number">12</span>, <span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> ages) {</span><br><span class="line">  <span class="built_in">console</span>.log(key);  <span class="comment">// 0, 1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>for...of</code>：用来遍历一个迭代器</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的遍历</span></span><br><span class="line"><span class="keyword">const</span> ages = [<span class="number">12</span>, <span class="number">13</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> ages) {</span><br><span class="line">  <span class="built_in">console</span>.log(key);  <span class="comment">// 12, 13</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>for...of</code>不能用来遍历对象，这是因为<code>ES6</code>中引入了<code>Iterator</code>，只有提供了<code>Iterator</code>接口的数据类型才可以使用<code>for...of</code>来循环遍历，而<code>Array</code>, <code>Set</code>, <code>Map</code>，某些类数组默认都提供了<code>Iterator</code>接口，所以它们可以使用<code>for...of</code>来进行遍历。</p>
</li>
</ol>
<h2 id="6-class"><a href="#6-class" class="headerlink" title="6. class"></a>6. <code>class</code></h2><h3 id="6-1-语法糖"><a href="#6-1-语法糖" class="headerlink" title="6.1 语法糖"></a>6.1 语法糖</h3><p><code>ES6</code>中支持<code>class</code>语法，不过，<code>ES6</code>的<code>class</code>不是新的对象继承模型，它只是原型链的语法糖表现形式，它的绝大部分功能，<code>ES5</code>都可以做到。新的<code>class</code>写法只是让对象原型的写法更加清晰，更像面向对象编程的语法而已。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i am andy'</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  run() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用new命令对类进行实例化，跟构造函数的用法完全一致</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(); <span class="comment">// i am andy</span></span><br><span class="line">person.run(); <span class="comment">// run</span></span><br></pre></td></tr></tbody></table></figure>

<p>构造函数的<code>prototype</code>属性，在<code>ES6</code>的类上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>上。</p>
<h3 id="6-2-属性不可枚举"><a href="#6-2-属性不可枚举" class="headerlink" title="6.2 属性不可枚举"></a>6.2 属性不可枚举</h3><p>另外，类内部所有定义的方法，都是不可枚举的，这点与<code>ES5</code>不一样，如果是以<code>ES5</code>定义的构造函数，则其内部的属性都是可枚举的：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'andy'</span>);</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  run() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Person.prototype);  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">// ['constructor', 'run']</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-3-constructor方法"><a href="#6-3-constructor方法" class="headerlink" title="6.3 constructor方法"></a>6.3 <code>constructor</code>方法</h3><p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，系统会自动加上一个默认的<code>constructor</code>方法。</p>
<p><code>constructor</code>方法默认返回实例对象<code>this</code>，也可以指定返回另外一个对象。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>() {</span><br><span class="line">    <span class="keyword">return</span> { <span class="attr">name</span>: <span class="string">'andy'</span> };</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aa = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(aa); <span class="comment">// { name: 'andy' }</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-4-原型"><a href="#6-4-原型" class="headerlink" title="6.4 原型"></a>6.4 原型</h3><p>与<code>ES5</code>一样，实例的属性除非显示定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) {</span><br><span class="line">    <span class="comment">// name和age定义在this对象上，即实例上</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// run方法定义在原型上</span></span><br><span class="line">  run() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'andy'</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">person.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'age'</span>); <span class="comment">// true</span></span><br><span class="line">person.hasOwnProperty(<span class="string">'run'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">person.__proto__.hasOwnProperty(<span class="string">'run'</span>); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>  <code>__proto__</code>并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，目前虽然在很多现代浏览器的<code>JS</code>引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，可以使用<code>getPrototypeOf</code>方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>
</blockquote>
<h3 id="6-5-取值函数-getter-与存值函数-setter"><a href="#6-5-取值函数-getter-与存值函数-setter" class="headerlink" title="6.5 取值函数(getter)与存值函数(setter)"></a>6.5 取值函数<code>(getter)</code>与存值函数<code>(setter)</code></h3><p>与<code>ES5</code>一样，在类内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(name) {</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">get</span> name() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> name(name) {</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-7-属性表达式"><a href="#6-7-属性表达式" class="headerlink" title="6.7 属性表达式"></a>6.7 属性表达式</h3><p>类的属性名，可以采用表达式：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = <span class="string">'run'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>() {}</span><br><span class="line">  </span><br><span class="line">  [action]() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-8-静态方法"><a href="#6-8-静态方法" class="headerlink" title="6.8 静态方法"></a>6.8 静态方法</h3><p><code>static</code>用来定义类的静态方法，类的静态方法不会被实例所继承，只能通过类直接调用。如果静态方法中有<code>this</code>，则此<code>this</code>指向这个类，而不是其实例，</p>
<p>子类可以继承父类的静态方法。</p>
<p>静态方法可以与非静态方法重名。</p>
<h3 id="6-9-类的继承"><a href="#6-9-类的继承" class="headerlink" title="6.9 类的继承"></a>6.9 类的继承</h3><p><code>Class</code>可以通过<code>extends</code>关键字实现继承，这比<code>ES5</code>通过修改原型链实现继承要清晰和方便。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的梳理属性和方法。如果不调用<code>super</code>方法，子类就得不到 <code>this</code>对象。</p>
<p>如果<code>super</code>作为对象，用在静态方法之中，这是<code>super</code>将指向父类，而不是父类的原型对象。</p>
<p>有几点值得注意：</p>
<ul>
<li>类内部默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式；</li>
<li>类的声明不会提升，如果要使用某个<code>class</code>，必须在使用之前定义它，否则会报错；</li>
<li>在类中定义函数不需要使用<code>function</code>关键字；</li>
<li>类可以通过<code>extends</code>继承一个父类，但是子类的<code>constructor</code>中需要执行<code>super()</code>函数；</li>
<li>类必须使用<code>new</code>关键字创建实例，不可直接执行，这点与<code>ES5</code>的构造函数不同；</li>
<li></li>
</ul>
<h2 id="7-module"><a href="#7-module" class="headerlink" title="7. module"></a>7. <code>module</code></h2><p>在<code>ES6</code>之前，<code>JavaScript</code>一直没有模块<code>(module)</code>体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。不过社区指定了一些模块加载方案，最主要的有<code>CommonJS</code>和<code>AMD</code>两种，前者用于服务器，后者用于浏览器。在<code>ES6</code>中提供了一个标准的模块加载方案，主要通过<code>export</code>和<code>import</code>实现：</p>
<h3 id="7-1-加载时机（编译时or运行时）"><a href="#7-1-加载时机（编译时or运行时）" class="headerlink" title="7.1 加载时机（编译时or运行时）"></a>7.1 加载时机（编译时or运行时）</h3><h4 id="7-1-1-运行时加载"><a href="#7-1-1-运行时加载" class="headerlink" title="7.1.1 运行时加载"></a>7.1.1 运行时加载</h4><p><code>CommonJS</code>和<code>AMD</code>模块，都只能在运行时确定模块的依赖关系。比如，<code>CommonJS</code>模块就是对象，输入时必须查找对象属性：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> { stat, readfile } = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码实质是整体加载<code>fs</code>模块，生成一个对象<code>_fs</code>，然后再从这个对象上面读取3个方法。这种加载成为“<strong>运行时加载</strong>”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<h4 id="7-1-2-编译时加载"><a href="#7-1-2-编译时加载" class="headerlink" title="7.1.2 编译时加载"></a>7.1.2 编译时加载</h4><p><code>ES6</code>模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。<code>ES6</code>模块不是对象，而是通过<code>export</code>命令显式指定输出的代码，再通过<code>import</code>命令输入：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> { stat, readfile } <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码的是实质是从<code>fs</code>模块加载两个方法，其他方法不加载。这种加载成为“<strong>编译时加载</strong>”，或者静态加载，即<code>ES6</code>可以在编译时就完成模块加载，效率要比<code>CommonJS</code>模块的加载方式高。当然，这也导致了没法引用<code>ES6</code>模块本身，因为它不是对象。</p>
<p>除了静态加载带来的各种好处，<code>ES6</code>模块还有以下好处：</p>
<ul>
<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持<code>ES6</code>模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器新<code>API</code>就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间，未来这些功能可以通过模块提供。</li>
</ul>
<p><code>ES6</code>的模块自动采用严格模式，不管你有没有在模块头部加上<code>'use strict'</code></p>
<h3 id="7-2-export"><a href="#7-2-export" class="headerlink" title="7.2 export"></a>7.2 <code>export</code></h3><p><code>export</code>命令主要用于规定模块的对外接口。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">'andy'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">12</span>;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'andy'</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> { name, age };</span><br></pre></td></tr></tbody></table></figure>

<p>上面两种<code>export</code>的使用方法都是正确的，<code>ES6</code>都会将当前文件视为一个模块，里边使用<code>export</code>对外暴露了两个变量。从可读性上来说更推荐方法2的写法，因为这种写法把所有的输出同一放文件最后，能一目了然看到当前文件都输出了哪些变量。</p>
<p>不只是变量，<code>export</code>也可用于输出方法和类：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// code...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> { run };</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="comment">// code ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> { Person };</span><br></pre></td></tr></tbody></table></figure>

<p>通常情况下，<code>export</code>输出的变量或者方法名就是该文件模块对外暴露的属性，但是也可以用<code>as</code>关键字进行重命名。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>) </span>{};</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>) </span>{};</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> {</span><br><span class="line">	v1 <span class="keyword">as</span> getAge,</span><br><span class="line">  v2 <span class="keyword">as</span> getName,</span><br><span class="line">  v2 <span class="keyword">as</span> getInfo,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另外，<code>export</code>输出的变量，与其对应的值是动态绑定关系，即通过该变量，可以获取到模块内部实时的值。这一点与<code>CommonJS</code>完全不同，<code>CommonJS</code>输出的是值的缓存，不存在动态更新。</p>
<p>最后，<code>export</code>模块只能放模块顶层，不能放入块级作用域或者方法中，否则会报错，这是因为处于条件代码块之中的<code>export</code>，没法做静态优化。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">var</span> name = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getName();</span><br><span class="line"><span class="comment">// 会报错</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-3-import"><a href="#7-3-import" class="headerlink" title="7.3 import"></a>7.3 <code>import</code></h3><p><code>import</code>命令主要用于引入其他模块提供的功能。使用<code>export</code>进行导出的接口，在其他文件中可以使用<code>import</code>进行引入。需要注意的是<code>import</code>引入的接口名必须与<code>export</code>导出的接口名一致，否则会报错，当然，也可以通过<code>as</code>关键字进行重命名：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常引入</span></span><br><span class="line"><span class="keyword">import</span> { getNamem, age } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过as关键字进行重命名</span></span><br><span class="line"><span class="keyword">import</span> { getName <span class="keyword">as</span> getInfo } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码，通过<code>import</code>导入的<code>age</code>是一个属性接口，是只读的，如果在当前文件修改<code>age</code>的值是不被允许的，但是如果<code>age</code>是一个对象的话，是可以修改其属性的，不过需要注意的一点是，这里的修改会反应到<code>person</code>模块中，当其他模块引入了<code>age</code>这个接口后，也会获取更新后的值，所以这种做法是不被推荐的。除非你想做一些全局变量。</p>
<p>注意：<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> { foo } <span class="keyword">from</span> <span class="string">'my_module'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码之前。也正是因为<code>import</code>是静态执行，所以不能使用变量和表达式，这些只能在运行时才能拿得到结果的语法解构。</p>
<p>最后，<code>import</code>语句会执行所加载的模块，如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码仅仅执行<code>lodash</code>模块，但是不输入任何值。如果多次重复执行同义句<code>import</code>，那么只会执行一次，而不会执行多次，即<code>import</code>是一个单例模式（<code>Singleton</code>）。</p>
<h3 id="7-4-模块的整体加载"><a href="#7-4-模块的整体加载" class="headerlink" title="7.4 模块的整体加载"></a>7.4 模块的整体加载</h3><p>除了指定某项输入值，还可以整体加载一个模块，要使用<code>*</code>指定一个对象，所有的输出值都会加载到这个对象上。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> person <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-5-export-default"><a href="#7-5-export-default" class="headerlink" title="7.5 export default"></a>7.5 <code>export default</code></h3><p><code>export default</code>用于为模块指定默认输出，</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// code ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码未当前文件模块默认导出了一个方法<code>getName</code>，由此方法进行导出，引入的时候不用关心接口名，可以直接重命名：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> getUserName <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>本质上，一个模块只能有一个<code>export default</code>，这也是为了通过<code>export default</code>导出的接口不需要使用大括号的原因。另一个本质是通过<code>export default</code>导出的接口默认接口名为<code>default</code>，即使是<code>export default</code>后边跟了方法名或者变量名，其与不跟的情况是一样的，所以在外部引入的时候可以随意重命名该接口。</p>
<p>一个模块文件只能有一个<code>export default</code>，但是同时可以存在多个<code>export</code>，所以引入时可以同时引入：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React;</span><br><span class="line"><span class="keyword">export</span> {</span><br><span class="line">	Component,</span><br><span class="line">  createRef,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, { Component } <span class="keyword">from</span> <span class="string">'react'</span>;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-6-export与import结合"><a href="#7-6-export与import结合" class="headerlink" title="7.6 export与import结合"></a>7.6 <code>export</code>与<code>import</code>结合</h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">export</span> { getName, getAge } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以理解为</span></span><br><span class="line"><span class="keyword">import</span> { getName, getAge } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="keyword">export</span> { getName, getAge };</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码方法1中，<code>export</code>与<code>import</code>结合使用，需要注意的是，此种引入导出方法，<code>getName</code>与<code>getAge</code>并没有在此文件中引入，只是对外转发了这两个方法，所以此文件不能使用者两个方法。</p>
<ol>
<li>模块的接口改名，可以采用下面方法：</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> { getAge <span class="keyword">as</span> getInfo } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>模块的整体输出：</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>默认接口的写法如下：</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> { <span class="keyword">default</span> } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="4">
<li>具体接口名改为默认接口：</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> { getName <span class="keyword">as</span> <span class="keyword">default</span> } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="5">
<li>默认接口改为具体接口名：</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> { <span class="keyword">default</span> <span class="keyword">as</span> getName } <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<ol start="6">
<li><p>整体导出改为接口名：</p>
<p>在<code>ES2020</code>之前，这种<code>import</code>语句，没有复合写法：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> personMethod <span class="keyword">from</span> <span class="string">'person'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><code>ES2020</code>补上了这种写法:</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> personMethod <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> personMethod <span class="keyword">from</span> <span class="string">'person'</span>;</span><br><span class="line"><span class="keyword">export</span> { personMethon };</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-7-模块的继承"><a href="#7-7-模块的继承" class="headerlink" title="7.7 模块的继承"></a>7.7 模块的继承</h3><p>模块也是可以继承的。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">'andy'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>{}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-Map和Set"><a href="#8-Map和Set" class="headerlink" title="8. Map和Set"></a>8. <code>Map</code>和<code>Set</code></h2><h3 id="8-1-Map"><a href="#8-1-Map" class="headerlink" title="8.1 Map"></a>8.1 <code>Map</code></h3><h4 id="8-1-1-基本用法"><a href="#8-1-1-基本用法" class="headerlink" title="8.1.1  基本用法"></a>8.1.1  基本用法</h4><p><code>ES6</code>提供了一个新的数据结构<code>Set</code>，它类似于数组，但是成员的值都是唯一的，没有重复值。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line"><span class="keyword">set</span>.add(2);</span><br><span class="line"><span class="keyword">set</span>.add(3);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.size);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">const docSet = new Set(document.querySelectorAll('div'));</span><br></pre></td></tr></tbody></table></figure>

<p>向<code>Set</code>加入值的时候，不会发生类型装换，所以5和’5’是两个不同的值。<code>Set</code>内部判断两个值是否相等，使用的算法类似于’===’运算符，主要区别是向<code>Set</code>加入值时认为<code>NaN</code>等于自身，而精确相当运算认为<code>NaN</code>不等于<code>NaN</code>，另外，两个对象总是不等的。</p>
<h4 id="8-1-2-Set实例的属性和方法"><a href="#8-1-2-Set实例的属性和方法" class="headerlink" title="8.1.2 Set实例的属性和方法"></a>8.1.2 <code>Set</code>实例的属性和方法</h4><ul>
<li><code>Set.prototype.constructoy</code>： <code>Set</code>的构造函数；</li>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数；</li>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回<code>Set</code>解构本身；</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功；</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否是<code>Set</code>的成员；</li>
<li><code>Set.prototype.clear()</code>：删除所有成员，没有返回值；</li>
<li><code>Set.prototype.keys()</code>：返回键名的遍历器；</li>
<li><code>Set.prototype.values()</code>：返回兼职的遍历器；</li>
<li><code>Set.prototype.entries()</code>：返回键值对的遍历器；</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员；</li>
</ul>
<p>由于<code>Set</code>解构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p>
<h3 id="8-2-WeakSet"><a href="#8-2-WeakSet" class="headerlink" title="8.2 WeakSet"></a>8.2 <code>WeakSet</code></h3><h4 id="8-2-1-含义"><a href="#8-2-1-含义" class="headerlink" title="8.2.1 含义"></a>8.2.1 含义</h4><p><code>WeakSet</code>解构与<code>Set</code>类似，也是不重复的值的集合，但是，它与<code>Set</code>有两个区别：</p>
<ol>
<li><code>WeakSet</code>的成员只能是对象，而不能是其他类型的值；</li>
<li><code>WeakSet</code>中的对象都是弱引用，即垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li>
</ol>
<p>鉴于<code>WeakSet</code>的特殊机制，所以其内部只适合临时存放一组对象，或者跟对象绑定的信息（比如DOM节点信息） ，只要这些对象在外部小时，它在<code>WeakSet</code>里面的引用就会自动消失。所以<code>WeakSet</code>的成员是不适合应用的，因为它随时会消失。另外，由于<code>WeakSet</code>内部有多少个成员，取决于内部垃圾回收机制什么时候运行，运行前后的成员数可能是不同的，而垃圾回收机制何时运行是不可预测的，所以<code>ES6</code>规定<code>WeakSet</code>不可遍历。</p>
<h4 id="8-2-2-方法"><a href="#8-2-2-方法" class="headerlink" title="8.2.2 方法"></a>8.2.2 方法</h4><ul>
<li><code>WeakSet.prototype.add(value)</code>：向<code>WeakSet</code>实例添加一个成员；</li>
<li><code>WeakSet.prototype.delete(value)</code>：删除一个成员；</li>
<li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在<code>WeakSet</code>实例之中。</li>
</ul>
<h3 id="8-3-Map"><a href="#8-3-Map" class="headerlink" title="8.3 Map"></a>8.3 <code>Map</code></h3><h4 id="8-3-1-基础含义"><a href="#8-3-1-基础含义" class="headerlink" title="8.3.1 基础含义"></a>8.3.1 基础含义</h4><p><code>JavaScript</code>的对象，本质上是键值对的集合，但是传统上只能用字符串作为<code>key</code>值。而<code>ES6</code>解除了这种限制，它的键值可以为任何类型的值，实现了真正意义上的值-值的集合。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> obj = { <span class="attr">name</span>: <span class="string">'andy'</span> };</span><br><span class="line"></span><br><span class="line">map.set(obj, <span class="string">'person'</span>);</span><br><span class="line">map.get(obj); <span class="comment">// person</span></span><br><span class="line"></span><br><span class="line">map.has(obj); <span class="comment">// true</span></span><br><span class="line">map.delete(obj); <span class="comment">// true</span></span><br><span class="line">map.has(obj); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>Map</code>构造函数接受数组以及任何具有<code>Iterator</code>接口的数据结构作为参数，生成一个新的<code>Map</code>实例。</p>
<ol>
<li>数组作为参数</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'andy'</span>],</span><br><span class="line">  [<span class="string">'age'</span>, <span class="number">12</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(items);</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li><code>set</code>实例作为参数</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([</span><br><span class="line">  ['name', 'andy'],</span><br><span class="line">  ['age', 12]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">const map = new Map(<span class="keyword">set</span>);</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><code>map</code>实例作为参数</li>
</ol>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">params.set(<span class="string">'namd'</span>, <span class="string">'andy'</span>);</span><br><span class="line">params.set(<span class="string">'age'</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(params);</span><br></pre></td></tr></tbody></table></figure>

<p>由上可知，<code>Map</code>的键实际上跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞的问题。<code>Map</code>同样将<code>NaN</code>视为同一个键。</p>
<h4 id="8-3-2-方法"><a href="#8-3-2-方法" class="headerlink" title="8.3.2 方法"></a>8.3.2 方法</h4><ul>
<li><code>Map.prototype.size</code>：返回<code>Map</code>解构的成员总数；</li>
<li><code>Map.prototype.set(key, value)</code>：设置一组键值对；</li>
<li><code>Map.prototype.get(key)</code>：返回<code>key</code>对应的<code>value</code>值；</li>
<li><code>Map.prototype.has(key)</code>：判断是否在当前<code>map</code>对象中；</li>
<li><code>Map.prototype.delete(key)</code>：删除某个<code>key</code>值；</li>
<li><code>Map.prototype.clear()</code>：清除整个<code>map</code>；</li>
<li><code>Map.prototype.keys()</code>：返回键名的遍历器；</li>
<li><code>Map.prototype.values()</code>：返回键值的遍历器；</li>
<li><code>Map.prototype.entries()</code>：返回所有成员的遍历器；</li>
<li><code>Map.prototype.forEach()</code>：遍历<code>Map</code>的所有成员；</li>
</ul>
<p><code>Map</code>转为数组最方便的方法，就是使用扩展运算符(…)</p>
<h4 id="8-3-3-数据结构互相转换"><a href="#8-3-3-数据结构互相转换" class="headerlink" title="8.3.3 数据结构互相转换"></a>8.3.3 数据结构互相转换</h4><ol>
<li><p><code>Map</code>转为数组</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'andy'</span>],</span><br><span class="line">  [<span class="string">'age'</span>, <span class="number">12</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...map]);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>数组转为<code>Map</code></p>
 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'name'</span>, <span class="string">'andy'</span>],</span><br><span class="line">  [<span class="string">'age'</span>, <span class="number">12</span>]</span><br><span class="line">]);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>Map</code>转对象</p>
<p> 如果所有<code>Map</code>的键都是字符串，它可以无损地转为对象。</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToObj</span>(<span class="params">map</span>) </span>{</span><br><span class="line">	<span class="keyword">var</span> result = {};</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) {</span><br><span class="line">		result[key] = value;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">	[<span class="string">'name'</span>, <span class="string">'andy'</span>],</span><br><span class="line">	[<span class="string">'age'</span>, <span class="number">12</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bb = mapToObj(map);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>对象转<code>Map</code></p>
<p> 对象转<code>Map</code>可以通过<code>Object.entries</code>，当然也可以自己实现一个转换函数。</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">const</span> person = { <span class="attr">name</span>: <span class="string">'andy'</span>, <span class="attr">age</span>: <span class="number">1</span> };</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(person));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToMap</span>(<span class="params">obj</span>) </span>{</span><br><span class="line">	<span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) {</span><br><span class="line">		map.set(key, obj[key]);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> map;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>Map</code>转<code>JSON</code></p>
<p> <code>Map</code>转为<code>JSON</code>要区分两种情况，一种情况是，<code>Map</code>的键名都是字符串，这时可以选择转为对象<code>JSON</code>，另一种情况是，<code>Map</code>的键名有非字符串，这时可以选择转为数组<code>JSON</code>。</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToJSON</span>(<span class="params">map</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(mapToObj(map));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToJSON</span>(<span class="params">map</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>JSON</code>转<code>Map</code></p>
<p> 正常情况下，<code>JSON</code>都可以转为<code>Map</code>。</p>
 <figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSONToMap</span>(<span class="params">json</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> objToMap(<span class="built_in">JSON</span>.parse(json));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="8-4-WeakMap"><a href="#8-4-WeakMap" class="headerlink" title="8.4 WeakMap"></a>8.4 <code>WeakMap</code></h3><h4 id="8-4-1-含义"><a href="#8-4-1-含义" class="headerlink" title="8.4.1 含义"></a>8.4.1 含义</h4><p><code>WeakMap</code>与<code>Map</code>解构类似，也是用于生成键值对的集合。他们也有两个区别点</p>
<ol>
<li><code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），其他类型不接受。</li>
<li><code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</li>
</ol>
<p><code>WeakMap</code>的设计目的在于，有时我们想在对啊ing上面存放一些数据，但是这会行程对于这个对啊ing的引用。一旦不再需要这个对象，我们要必须删除这个应用，否则垃圾回收机制就不会释放其占用的内存。</p>
<p>它最适用的情况还是<code>DOM</code>的处理</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">'some information'</span>);</span><br><span class="line">wm.get(element) <span class="comment">// "some information"</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="8-4-2-语法"><a href="#8-4-2-语法" class="headerlink" title="8.4.2 语法"></a>8.4.2 语法</h4><p><code>WeakMap</code>与<code>Map</code>在API上的区别主要有两个；</p>
<ol>
<li>没有遍历操作，即没有<code>keys</code>，<code>values</code>，<code>entries</code>方法，也没有<code>size</code>属性，这也是因为不知道何时才会运行垃圾回收机制，其内部的数量有可能会变化。</li>
<li>无法清空，即不支持<code>clear</code>方法</li>
</ol>
<h4 id="8-4-3-API"><a href="#8-4-3-API" class="headerlink" title="8.4.3 API"></a>8.4.3 <code>API</code></h4><p><code>WeakMap</code>只有四个方法可以用：</p>
<ol>
<li><code>get()</code></li>
<li><code>set()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code></li>
</ol>
<h2 id="9-Proxy"><a href="#9-Proxy" class="headerlink" title="9. Proxy"></a>9. <code>Proxy</code></h2><h3 id="9-1-基础"><a href="#9-1-基础" class="headerlink" title="9.1 基础"></a>9.1 基础</h3><p><code>Proxy</code>用于修改某些默认的操作行为。可以理解为，在目标对象之前架设一层“拦截”，外接对该对象的访问，都必须经过这层拦截。<code>Proxy</code>这个词原意是代理，用在这里表示由他来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>({}, {</span><br><span class="line">	<span class="keyword">get</span>(target, propKey, receiver) {</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'get:'</span>, target, propKey);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">	},</span><br><span class="line">	<span class="keyword">set</span>(target, propKey, value, receiver) {</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'set:'</span>, target, propKey, value, receiver);</span><br><span class="line">		<span class="built_in">Reflect</span>.set(target, propKey, value);</span><br><span class="line">	}</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>

<p><code>Proxy</code>对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法，其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数用来定制拦截行为。</p>
<h3 id="9-2-拦截操作"><a href="#9-2-拦截操作" class="headerlink" title="9.2 拦截操作"></a>9.2 拦截操作</h3><p><code>Proxy</code>支持的拦截操作一共有13中：</p>
<ul>
<li><code>get(target, propKey, receiver)</code>：拦截对象属性的读取；</li>
<li><code>set(target, propKey, value, receiver)</code>：拦截对象属性的设置；</li>
<li><code>has(target, propKey)</code>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值；</li>
<li><code>delete(target, propKey)</code>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值；</li>
<li><code>ownKeys(target)</code>：拦截<code>Object.getOwnPropertyNames(proxy)</code>，<code>Object.getOwnPropertySymbols(proxy)</code>，<code>Object.keys(proxy)</code>， <code>for...in</code>循环，返回一个包含目标对象所有自身属性的数组；</li>
<li><code>getOwnPropertyDescriptor(target, propKey)</code>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象；</li>
<li><code>defineProperty(target, propKey, propDesc)</code>：拦截<code>Object.defineProperty(proxy, propKey, propDesc)</code>，<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值；</li>
<li><code>preventExtensions(target)</code>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值；</li>
<li><code>getPrototypeOf(target)</code>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象；</li>
<li><code>setPrototypeOf(target, proto)</code>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值;</li>
<li><code>isExtensible(target)</code>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值;</li>
<li><code>apply(target, object, args)</code>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><code>construct(target, args)</code>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
</ul>
<h3 id="9-3-优势"><a href="#9-3-优势" class="headerlink" title="9.3 优势"></a>9.3 优势</h3><p>在<code>Proxy</code>出世之前，我们用<code>Object.defineProperty</code>来实现一个对象操作的拦截。<code>Proxy</code>相对于<code>Object.defineProperty</code>可谓是一个升级版，那么它究竟有什么优势呢：</p>
<ol>
<li><p>支持数组，<code>Proxy</code>本身支持对数组的拦截，不需要再对数组进行重载，省去了众多<code>hack</code>；</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, {</span><br><span class="line">    <span class="keyword">get</span> (target, key, receiver) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'get'</span>, key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    },</span><br><span class="line">    <span class="keyword">set</span> (target, key, value, receiver) {</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'set'</span>, key, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    }</span><br><span class="line">})</span><br><span class="line">proxy.push(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 能够打印出很多内容</span></span><br><span class="line"><span class="comment">// get push     (寻找 proxy.push 方法)</span></span><br><span class="line"><span class="comment">// get length   (获取当前的 length)</span></span><br><span class="line"><span class="comment">// set 3 4      (设置 proxy[3] = 4)</span></span><br><span class="line"><span class="comment">// set length 4 (设置 proxy.length = 4)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>针对对象，<code>Proxy</code>针对的是整个对象，而非对象中的某个属性，所以也就不需要对<code>keys</code>进行遍历；</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  name: <span class="string">'Eason'</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> handler = {</span><br><span class="line">  <span class="keyword">get</span> (target, key, receiver) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">  },</span><br><span class="line">  <span class="keyword">set</span> (target, key, value, receiver) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>, key, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">proxy.name = <span class="string">'Zoe'</span> <span class="comment">// set name Zoe</span></span><br><span class="line">proxy.age = <span class="number">18</span> <span class="comment">// set age 18</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>嵌套支持，本质上，Proxy 也是不支持嵌套的，这点和 Object.defineProperty() 是一样的。因此也需要通过逐层遍历来解决。Proxy 的写法是在 get 里面递归调用 Proxy 并返回，代码如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">  info: {</span><br><span class="line">    name: <span class="string">'eason'</span>,</span><br><span class="line">    blogs: [<span class="string">'webpack'</span>, <span class="string">'babel'</span>, <span class="string">'cache'</span>]</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> handler = {</span><br><span class="line">  <span class="keyword">get</span> (target, key, receiver) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>, key)</span><br><span class="line">    <span class="comment">// 递归创建并返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target[key] === <span class="string">'object'</span> && target[key] !== <span class="literal">null</span>) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target[key], handler)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">  },</span><br><span class="line">  <span class="keyword">set</span> (target, key, value, receiver) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>, key, value)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line"><span class="comment">// 以下两句都能够进入 set</span></span><br><span class="line">proxy.info.name = <span class="string">'Zoe'</span></span><br><span class="line">proxy.info.blogs.push(<span class="string">'proxy'</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><code>Proxy</code>提供了比<code>Object.defineProperty</code>更多的拦截方法，扩展了很多功能。</p>
</li>
</ol>
<h2 id="10-Reflect"><a href="#10-Reflect" class="headerlink" title="10. Reflect"></a>10. <code>Reflect</code></h2><h3 id="10-1-基础"><a href="#10-1-基础" class="headerlink" title="10.1 基础"></a>10.1 基础</h3><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是<code>ES6</code>为了操作对象而提供的新<code>API</code>。</p>
<p><code>Reflect</code>对象的设计目的有以下几个：</p>
<ol>
<li>将<code>Object</code>对象的一些明显属于语言内部的方法，放到<code>Reflect</code>上，现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只在<code>Reflect</code>对象上部署。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法；</li>
<li>修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>；</li>
<li>让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</li>
<li>与<code>Proxy</code>对象的方法一一对应。只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</li>
</ol>
<h3 id="10-2-静态方法"><a href="#10-2-静态方法" class="headerlink" title="10.2 静态方法"></a>10.2 静态方法</h3><ul>
<li><code>Reflect.apply(target, thisArg, args)</code></li>
<li><code>Reflect.construct(target, args)</code></li>
<li><code>Reflect.get(target, name, receiver)</code></li>
<li><code>Reflect.set(target, name, value, receiver)</code></li>
<li><code>Reflect.defineProperty(target, name, desc)</code></li>
<li><code>Reflect.deleteProperty(target, name)</code></li>
<li><code>Reflect.has(target, name)</code></li>
<li><code>Reflect.ownKeys(target)</code></li>
<li><code>Reflect.isExtensible(target)</code></li>
<li><code>Reflect.preventExtensions(target)</code></li>
<li><code>Reflect.getOwnPropertyDescriptor(target, name)</code></li>
<li><code>Reflect.getPrototypeOf(target)</code></li>
<li><code>Reflect.setPrototypeOf(target, prototype)</code></li>
</ul>
<h2 id="11-Promise"><a href="#11-Promise" class="headerlink" title="11. Promise"></a>11. <code>Promise</code></h2><h3 id="11-1-基础"><a href="#11-1-基础" class="headerlink" title="11.1 基础"></a>11.1 基础</h3><p>所谓<code>Promise</code>，简单说是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code>是一个对象，从它可以获取异步操作的消息。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>{</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (){</span><br><span class="line">    resolve(value);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    reject(error);</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="11-2-方法"><a href="#11-2-方法" class="headerlink" title="11.2 方法"></a>11.2 方法</h3><ul>
<li><code>Promise.all()</code></li>
</ul>
<p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></tbody></table></figure>

<p><code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<ul>
<li><code>Promise.race()</code></li>
</ul>
<p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></tbody></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<ul>
<li><code>Promise.allSettled()</code></li>
</ul>
<p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled" target="_blank" rel="noopener">ES2020</a> 引入。</p>
<ul>
<li><code>Promise.any()</code></li>
</ul>
<p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any" target="_blank" rel="noopener"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a><code>Generator</code>函数</h2><a id="more"></a>

</body></html>
    </div>
</article>
        </main>
    </div>
</body>

</html>
